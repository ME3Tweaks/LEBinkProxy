#pragma comment(linker, "/export:BinkAllocateFrameBuffers=bink2w64_original.BinkAllocateFrameBuffers")
#pragma comment(linker, "/export:BinkClose=bink2w64_original.BinkClose")
#pragma comment(linker, "/export:BinkCloseTrack=bink2w64_original.BinkCloseTrack")
#pragma comment(linker, "/export:BinkControlBackgroundIO=bink2w64_original.BinkControlBackgroundIO")
#pragma comment(linker, "/export:BinkCopyToBuffer=bink2w64_original.BinkCopyToBuffer")
#pragma comment(linker, "/export:BinkCopyToBufferRect=bink2w64_original.BinkCopyToBufferRect")
#pragma comment(linker, "/export:BinkDoFrame=bink2w64_original.BinkDoFrame")
#pragma comment(linker, "/export:BinkDoFrameAsync=bink2w64_original.BinkDoFrameAsync")
#pragma comment(linker, "/export:BinkDoFrameAsyncMulti=bink2w64_original.BinkDoFrameAsyncMulti")
#pragma comment(linker, "/export:BinkDoFrameAsyncWait=bink2w64_original.BinkDoFrameAsyncWait")
#pragma comment(linker, "/export:BinkDoFramePlane=bink2w64_original.BinkDoFramePlane")
#pragma comment(linker, "/export:BinkFindXAudio2WinDevice=bink2w64_original.BinkFindXAudio2WinDevice")
#pragma comment(linker, "/export:BinkFreeGlobals=bink2w64_original.BinkFreeGlobals")
#pragma comment(linker, "/export:BinkGetError=bink2w64_original.BinkGetError")
#pragma comment(linker, "/export:BinkGetFrameBuffersInfo=bink2w64_original.BinkGetFrameBuffersInfo")
#pragma comment(linker, "/export:BinkGetGPUDataBuffersInfo=bink2w64_original.BinkGetGPUDataBuffersInfo")
#pragma comment(linker, "/export:BinkGetKeyFrame=bink2w64_original.BinkGetKeyFrame")
#pragma comment(linker, "/export:BinkGetPlatformInfo=bink2w64_original.BinkGetPlatformInfo")
#pragma comment(linker, "/export:BinkGetRealtime=bink2w64_original.BinkGetRealtime")
#pragma comment(linker, "/export:BinkGetRects=bink2w64_original.BinkGetRects")
#pragma comment(linker, "/export:BinkGetSummary=bink2w64_original.BinkGetSummary")
#pragma comment(linker, "/export:BinkGetTrackData=bink2w64_original.BinkGetTrackData")
#pragma comment(linker, "/export:BinkGetTrackID=bink2w64_original.BinkGetTrackID")
#pragma comment(linker, "/export:BinkGetTrackMaxSize=bink2w64_original.BinkGetTrackMaxSize")
#pragma comment(linker, "/export:BinkGetTrackType=bink2w64_original.BinkGetTrackType")
#pragma comment(linker, "/export:BinkGoto=bink2w64_original.BinkGoto")
#pragma comment(linker, "/export:BinkLogoAddress=bink2w64_original.BinkLogoAddress")
#pragma comment(linker, "/export:BinkNextFrame=bink2w64_original.BinkNextFrame")
#pragma comment(linker, "/export:BinkOpen=bink2w64_original.BinkOpen")
#pragma comment(linker, "/export:BinkOpenDirectSound=bink2w64_original.BinkOpenDirectSound")
#pragma comment(linker, "/export:BinkOpenMiles=bink2w64_original.BinkOpenMiles")
#pragma comment(linker, "/export:BinkOpenTrack=bink2w64_original.BinkOpenTrack")
#pragma comment(linker, "/export:BinkOpenWaveOut=bink2w64_original.BinkOpenWaveOut")
#pragma comment(linker, "/export:BinkOpenWithOptions=bink2w64_original.BinkOpenWithOptions")
#pragma comment(linker, "/export:BinkOpenXAudio2=bink2w64_original.BinkOpenXAudio2")
#pragma comment(linker, "/export:BinkOpenXAudio27=bink2w64_original.BinkOpenXAudio27")
#pragma comment(linker, "/export:BinkOpenXAudio28=bink2w64_original.BinkOpenXAudio28")
#pragma comment(linker, "/export:BinkPause=bink2w64_original.BinkPause")
#pragma comment(linker, "/export:BinkRegisterFrameBuffers=bink2w64_original.BinkRegisterFrameBuffers")
#pragma comment(linker, "/export:BinkRegisterGPUDataBuffers=bink2w64_original.BinkRegisterGPUDataBuffers")
#pragma comment(linker, "/export:BinkRequestStopAsyncThread=bink2w64_original.BinkRequestStopAsyncThread")
#pragma comment(linker, "/export:BinkRequestStopAsyncThreadsMulti=bink2w64_original.BinkRequestStopAsyncThreadsMulti")
#pragma comment(linker, "/export:BinkService=bink2w64_original.BinkService")
#pragma comment(linker, "/export:BinkSetError=bink2w64_original.BinkSetError")
#pragma comment(linker, "/export:BinkSetFileOffset=bink2w64_original.BinkSetFileOffset")
#pragma comment(linker, "/export:BinkSetFrameRate=bink2w64_original.BinkSetFrameRate")
#pragma comment(linker, "/export:BinkSetIO=bink2w64_original.BinkSetIO")
#pragma comment(linker, "/export:BinkSetIOSize=bink2w64_original.BinkSetIOSize")
#pragma comment(linker, "/export:BinkSetMemory=bink2w64_original.BinkSetMemory")
#pragma comment(linker, "/export:BinkSetOSFileCallbacks=bink2w64_original.BinkSetOSFileCallbacks")
#pragma comment(linker, "/export:BinkSetPan=bink2w64_original.BinkSetPan")
#pragma comment(linker, "/export:BinkSetSimulate=bink2w64_original.BinkSetSimulate")
#pragma comment(linker, "/export:BinkSetSoundOnOff=bink2w64_original.BinkSetSoundOnOff")
#pragma comment(linker, "/export:BinkSetSoundSystem=bink2w64_original.BinkSetSoundSystem")
#pragma comment(linker, "/export:BinkSetSoundSystem2=bink2w64_original.BinkSetSoundSystem2")
#pragma comment(linker, "/export:BinkSetSoundTrack=bink2w64_original.BinkSetSoundTrack")
#pragma comment(linker, "/export:BinkSetSpeakerVolumes=bink2w64_original.BinkSetSpeakerVolumes")
#pragma comment(linker, "/export:BinkSetVideoOnOff=bink2w64_original.BinkSetVideoOnOff")
#pragma comment(linker, "/export:BinkSetVolume=bink2w64_original.BinkSetVolume")
#pragma comment(linker, "/export:BinkSetWillLoop=bink2w64_original.BinkSetWillLoop")
#pragma comment(linker, "/export:BinkShouldSkip=bink2w64_original.BinkShouldSkip")
#pragma comment(linker, "/export:BinkStartAsyncThread=bink2w64_original.BinkStartAsyncThread")
#pragma comment(linker, "/export:BinkUtilCPUs=bink2w64_original.BinkUtilCPUs")
#pragma comment(linker, "/export:BinkUtilFree=bink2w64_original.BinkUtilFree")
#pragma comment(linker, "/export:BinkUtilMalloc=bink2w64_original.BinkUtilMalloc")
#pragma comment(linker, "/export:BinkUtilMutexCreate=bink2w64_original.BinkUtilMutexCreate")
#pragma comment(linker, "/export:BinkUtilMutexDestroy=bink2w64_original.BinkUtilMutexDestroy")
#pragma comment(linker, "/export:BinkUtilMutexLock=bink2w64_original.BinkUtilMutexLock")
#pragma comment(linker, "/export:BinkUtilMutexLockTimeOut=bink2w64_original.BinkUtilMutexLockTimeOut")
#pragma comment(linker, "/export:BinkUtilMutexUnlock=bink2w64_original.BinkUtilMutexUnlock")
#pragma comment(linker, "/export:BinkUtilSoundGlobalLock=bink2w64_original.BinkUtilSoundGlobalLock")
#pragma comment(linker, "/export:BinkUtilSoundGlobalUnlock=bink2w64_original.BinkUtilSoundGlobalUnlock")
#pragma comment(linker, "/export:BinkWait=bink2w64_original.BinkWait")
#pragma comment(linker, "/export:BinkWaitStopAsyncThread=bink2w64_original.BinkWaitStopAsyncThread")
#pragma comment(linker, "/export:BinkWaitStopAsyncThreadsMulti=bink2w64_original.BinkWaitStopAsyncThreadsMulti")
#pragma comment(linker, "/export:RADTimerRead=bink2w64_original.RADTimerRead")


#include <windows.h>
#include <psapi.h>
#include <tlhelp32.h>

#include <cstdio>
#include <cstring>
#include "minhook/include/MinHook.h"
#include "patterns.h"


#pragma region Structs and typedefs

struct FFramePartial;
struct UFunctionPartial;


//// A prototype of a GNatives table item, such as
//// bound UScript natives or, most commonly, ProcessInternal.
//typedef void(__thiscall* tNative)(void* pObject, FFramePartial& pFrame, void* pResult);
//tNative* GNatives = nullptr;

// A prototype of a function which LE uses to decode
// a char name from a FNameEntry structure.
typedef void* (__stdcall* tGetName)(void* name, wchar_t* outBuffer);
tGetName GetName = nullptr;

// A prototype of UFunction::Bind method used to
// bind UScript functions to native implementations.
typedef void(__thiscall* tUFunctionBind)(void* pFunction);
tUFunctionBind UFunctionBind = nullptr;
tUFunctionBind UFunctionBind_orig = nullptr;


// A partial representation of a FFrame structure used
// across the UScript VM to encapsulate an execution stack frame.
#pragma pack(4)
struct FFramePartial
{
    BYTE a[0x1C];
    void* Object; // 0x1C
    BYTE* Code;   // 0x24

    //void Step(void* pObject, void* pResult)
    //{
    //    INT B = *this->Code++;
    //    (*GNatives[B])(pObject, *this, pResult);
    //}
};

// A partial representation of a UFunction class.
struct UFunctionPartial
{
    BYTE a[0xF8];
    void* Func;
};

#pragma endregion


// Input/output utilities.
namespace IO
{
    void SetupConsole()
    {
        AllocConsole();
        freopen_s((FILE**)stdout, "CONOUT$", "w", stdout);
        freopen_s((FILE**)stderr, "CONOUT$", "w", stderr);

        HANDLE console = GetStdHandle(STD_OUTPUT_HANDLE);
        CONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo;
        GetConsoleScreenBufferInfo(console, &lpConsoleScreenBufferInfo);
        SetConsoleScreenBufferSize(console, { lpConsoleScreenBufferInfo.dwSize.X, 30000 });
    }

    void TeardownConsole()
    {
        FreeConsole();
    }
}

// DRM handling utilities.
namespace DRM {
    int GoodTitleHit = 0;
    const int RequiredHits = 1;

    static BOOL CALLBACK enumWindowCallback(HWND hWnd, LPARAM lparam)
    {
        int length = GetWindowTextLength(hWnd);
        wchar_t buffer[512];
        GetWindowText(hWnd, buffer, length + 1);

        if (GoodTitleHit == RequiredHits)
        {
            printf("GPollingDRMWaiter: hit enough times!\n");
            return FALSE;
        }

        if (IsWindowVisible(hWnd) && length != 0 && wcsstr(buffer, L"Mass Effect") != NULL)
        {
            //wprintf_s(L"  Window: %s\n", buffer);
            if (0 == wcscmp(L"Mass Effect", buffer))
            {
                ++GoodTitleHit;
            }
        }

        return TRUE;
    }

    void WaitForFuckingDenuvo()
    {
        printf("GPollingDRMWaiter: waiting for DRM...\n");
        do
        {
            EnumWindows(enumWindowCallback, NULL);
        } while (GoodTitleHit != RequiredHits);
        printf("GPollingDRMWaiter: finished waiting for DRM!\n");
    }
}

// Memory utilities.
namespace Memory
{
    wchar_t* GetName(void* pObj)
    {
        wchar_t buffer[2048];
        wchar_t** name = (wchar_t**)::GetName((BYTE*)pObj + 0x48, buffer);
        //wprintf_s(L"Utilities::GetName buffer = %s, returned = %s\n", buffer, *(wchar_t**)name);
        return *name;
    }

    bool IsExecutableAddress(LPVOID pAddress)
    {
        MEMORY_BASIC_INFORMATION mi;
        VirtualQuery(pAddress, &mi, sizeof(mi));
        return (mi.State == MEM_COMMIT && (mi.Protect & (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY)));
    }

    HMODULE GetGameModuleRange(BYTE** pStart, BYTE** pEnd)
    {
        HMODULE exeModule = GetModuleHandle(nullptr);
        MODULEINFO exeModuleInfo;
        if (!GetModuleInformation(GetCurrentProcess(), exeModule, &exeModuleInfo, sizeof(MODULEINFO)))
        {
            return nullptr;
        }

        *pStart = (BYTE*)exeModuleInfo.lpBaseOfDll;
        *pEnd = *pStart + exeModuleInfo.SizeOfImage;

        return exeModule;
    }

    BYTE* ScanProcess(BYTE* pattern, BYTE* mask)
    {
        int patternLength = strlen((char*)mask);

        BYTE *start, *end, *pointer;
        if (!GetGameModuleRange(&start, &end))
        {
            printf_s("ScanProcess: ERROR: GetGameModuleRange failed.\n");
            return nullptr;
        }

        //printf_s("Module range = %p - %p\n", start, end);
        pointer = start;

        while (pointer < end)
        {
            for (int matchLength = 0; matchLength < patternLength; matchLength++)
            {
                if (matchLength + 1 == patternLength)
                {
                    return pointer;
                }
                if (pointer + matchLength >= end)
                {
                    return nullptr;
                }
                if ((pattern[matchLength] != pointer[matchLength]) && (mask[matchLength] != '?'))
                {
                    break;
                }
            }

            pointer++;
        }
        return nullptr;
    }

    void SuspendAllOtherThreads()
    {
        DWORD currentThreadId = GetCurrentThreadId();
        DWORD currentProcessId = GetCurrentProcessId();

        HANDLE h = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
        if (h != INVALID_HANDLE_VALUE)
        {
            THREADENTRY32 te;
            te.dwSize = sizeof(te);
            if (Thread32First(h, &te))
            {
                do
                {
                    if (te.dwSize >= FIELD_OFFSET(THREADENTRY32, th32OwnerProcessID) + sizeof(te.th32OwnerProcessID))
                    {
                        if (te.th32OwnerProcessID == currentProcessId && te.th32ThreadID != currentThreadId)
                        {
                            //printf_s("Suspending pid 0x%04x tid 0x%04x\n", te.th32OwnerProcessID, te.th32ThreadID);
                            HANDLE thread = OpenThread(THREAD_SUSPEND_RESUME, FALSE, te.th32ThreadID);
                            if (thread == NULL)
                            {
                                printf_s("Failed to open thread.\n");
                            }
                            else
                            {
                                if (SuspendThread(thread) == -1)
                                {
                                    printf_s("Failed to suspend thread.\n");
                                }
                                else
                                {
                                    CloseHandle(thread);
                                }
                            }
                        }
                    }

                    te.dwSize = sizeof(te);
                } while (Thread32Next(h, &te));
            }
            CloseHandle(h);
        }
    }

    void ResumeAllOtherThreads()
    {
        DWORD currentThreadId = GetCurrentThreadId();
        DWORD currentProcessId = GetCurrentProcessId();

        HANDLE h = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
        if (h != INVALID_HANDLE_VALUE)
        {
            THREADENTRY32 te;
            te.dwSize = sizeof(te);
            if (Thread32First(h, &te))
            {
                do
                {
                    if (te.dwSize >= FIELD_OFFSET(THREADENTRY32, th32OwnerProcessID) + sizeof(te.th32OwnerProcessID))
                    {
                        if (te.th32OwnerProcessID == currentProcessId && te.th32ThreadID != currentThreadId)
                        {
                            //printf("Resuming pid 0x%04x tid 0x%04x\n", te.th32OwnerProcessID, te.th32ThreadID);
                            HANDLE thread = OpenThread(THREAD_SUSPEND_RESUME, FALSE, te.th32ThreadID);
                            if (thread == NULL)
                            {
                                printf_s("Failed to open thread.\n");
                            }
                            else
                            {
                                if (ResumeThread(thread) == -1)
                                {
                                    printf_s("Failed to resume thread.\n");
                                }
                                else
                                {
                                    CloseHandle(thread);
                                }
                            }
                        }
                    }

                    te.dwSize = sizeof(te);
                } while (Thread32Next(h, &te));
            }
            CloseHandle(h);
        }
    }
}

// Hook functions definitions.
namespace Hooks
{
    void AlwaysPositiveNative(void* pObject, FFramePartial& pFrame, void* pResult)
    {
        wprintf_s(L"AlwaysPositiveNative: called for %s.\n", Memory::GetName(pObject));

        pFrame.Code++;
        //if (*pFrame.Code == 0x41)
        //{
        //    pFrame.Step(pFrame.Object, NULL);
        //}

        *(long long*)pResult = TRUE;
    }

    void UFunctionBind(void* pFunction)
    {
        auto name = Memory::GetName(pFunction);

        UFunctionBind_orig(pFunction);

        if (0 == wcscmp(name, L"IsShippingPCBuild") || 0 == wcscmp(name, L"IsFinalReleaseDebugConsoleBuild"))
        {
            wprintf_s(L"UFunction::Bind(%s) pFunction = 0x%p, Func = 0x%p\n", name, pFunction, *(void**)((BYTE*)pFunction + 0xF8));
            ((UFunctionPartial*)pFunction)->Func = Hooks::AlwaysPositiveNative;
            wprintf_s(L"UFunction::Bind(%s) func set to %p\n", name, *(void**)((BYTE*)pFunction + 0xF8));
        }
    }
}


bool FindOffsets()
{
    BYTE* temp = nullptr;

    // 0x00000001401029F0   ;   0x001029F0
    //UFunctionBind = (tUFunctionBind)0x00000001401029F0;
    temp = Memory::ScanProcess(LE1_UFunctionBind_Pattern, LE1_UFunctionBind_Mask);
    if (!temp)
    {
        printf("FindOffsets: ERROR: failed to find UFunction::Bind.\n");
        return false;
    }
    printf("FindOffsets: found UFunction::Bind at %p.\n", temp);
    UFunctionBind = (tUFunctionBind)temp;

    // 0x00000001400E4B50   ;   0x000E4B50
    //GetName = (tGetName)0x00000001400E4B50;
    temp = Memory::ScanProcess(LE1_GetName_Pattern, LE1_GetName_Mask);
    if (!temp)
    {
        printf("FindOffsets: ERROR: failed to find GetName.\n");
        return false;
    }
    printf("FindOffsets: found GetName at %p\n", temp);
    GetName = (tGetName)temp;

    //// 0x0000000141822C70   ;   ...
    //GNatives = (tNative*)0x0000000141822C70;

    return true;
}


void __stdcall OnAttach()
{
    MH_STATUS status;

    IO::SetupConsole();
    printf_s("OnAttach: hello there!\n");


    // Initialize MinHook.
    status = MH_Initialize();
    if (status != MH_OK)
    {
        printf_s("OnAttach: ERROR: failed to initialize MinHook.\n");
        return;
    }


    // Wait until the game is decrypted.
    DRM::WaitForFuckingDenuvo();


    // Find offsets for UFunction::Bind and GetName.
    // Other threads are suspended for the duration of the search.
    Memory::SuspendAllOtherThreads();
    if (!FindOffsets())
    {
        printf_s("OnAttach: aborting...\n");
        return;
    }
    Memory::ResumeAllOtherThreads();


    // Set up UFunction::Bind hook.
    status = MH_CreateHook(UFunctionBind, Hooks::UFunctionBind, reinterpret_cast<LPVOID*>(&UFunctionBind_orig));
    if (status != MH_OK)
    {
        printf_s("OnAttach: ERROR: MH_CreateHook failed, status = %s\n", MH_StatusToString(status));
        if (status == MH_ERROR_NOT_EXECUTABLE) printf_s("    (target: %d, hook: %d)\n", Memory::IsExecutableAddress(UFunctionBind), Memory::IsExecutableAddress(Hooks::UFunctionBind));
        return;
    }
    printf_s("OnAttach: hook created.\n");

    // Enable the hook we set up previously.
    status = MH_EnableHook(UFunctionBind);
    if (status != MH_OK)
    {
        printf_s("OnAttach: ERROR: MH_EnableHook failed, status = %s\n", MH_StatusToString(status));
        return;
    }
    printf_s("OnAttach: hook enabled.\n");
}

void __stdcall OnDetach()
{
    printf_s("OnDetach: goodbye :(\n");
    IO::TeardownConsole();
}

BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, LPVOID lpReserved) {
    switch (dwReason) {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hModule);
        CreateThread(nullptr, 0, (LPTHREAD_START_ROUTINE)OnAttach, nullptr, 0, nullptr);
        return TRUE;

    case DLL_PROCESS_DETACH:
        OnDetach();
        return TRUE;

    default:
        return TRUE;
    }
}
